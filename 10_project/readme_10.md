Task 1
Давай начнем с самого простого. В этом упражнении тебе необходимо получить отфильтрованные данные из таблицы в базе данных. Почему важно фильтровать данные именно в запросе, а не после этого в библиотеке Pandas? Потому что таблицы могут иметь огромный размер. Если ты попыташься получить всю таблицу, то не сможешь ее "переварить" – у тебя может не хватить оперативной памяти. Всегда помни об этом.

Первый способ фильтрации — выбрать только те столбцы, которые тебе действительно нужны. Второй способ — выбрать только те строки, которые тебе действительно нужны.

Подробное описание задания:

Помести базу данных в подкаталог data в корневом каталоге, используемом в рамках этого проекта.
Создай соединение с базой данных с помощью библиотеки sqlite3.
Получи схему таблицы pageviews с помощью pd.io.sql.read_sql и запроса PRAGMA table_info(pageviews);.
Получи только первые 10 строк таблицы pageviews, чтобы проверить, как она выглядит.
Получи подтаблицу с помощью только одного запроса, в котором:
используются только uid и datetime;
используются только данные пользователей (user_*), и не используются данные администраторов;
сортировка выполняется по uid в порядке возрастания;
столбец индекса — это datetime;
datetime преобразован в DatetimeIndex;
имя датафрейма — pageviews.
Закрой соединение с базой данных.
Task 2
А теперь давай усложним задачу.Ты знаешь, что такое подзапрос? Это как запрос, но только внутри запроса. Чем он может быть полезен? Например, с его помощью можно сделать определенную агрегацию для выбранных данных. Однако следует помнить, что в первую очередь выполняются вложенные запросы, и только после этого — основной запрос.

Что тебе нужно сделать:

Создай соединение с базой данных с помощью библиотеки sqlite3.
Получи схему таблицы checker.
Получи только первые 10 строк таблицы checker, чтобы проверить, как она выглядит.
Подсчитай, сколько строк удовлетворяют следующим условиям, используя только один запрос с любым количеством подзапросов.
Подсчитай количество строк из таблицы pageviews, но только с пользователями из таблицы checker, у которых:
status = 'ready' (мы не хотим анализировать логи со статусом checking);
numTrials = 1 (мы хотим проанализировать только первые коммиты, поскольку только они информируют о том, когда студент начал работать над лабораторным заданием);
названия лабораторных заданий должны быть только из следующего списка: laba04, laba04s, laba05, laba06, laba06s, project1. Только они были активными во время проведения эксперимента.
Сохрани их в датафрейме checkers в столбце cnt. Датафрейм будет представлять собой только одну ячейку.
Закрой соединение.
Task 3
В этом упражнении ты создашь так называемую витрину данных. Она представляет собой таблицу, которую можно использовать для аналитических целей. Обычно она создается путем объединения нескольких отдельных таблиц. В этом упражнении мы будем собирать различные данные о наших пользователях: когда они сделали свои первые коммиты, когда они впервые посетили ленту новостей и т. д. Это поможет позднее выполнить анализ данных.

Что тебе нужно сделать в этом упражнении (ознакомься с полным описанием задания):

Создай соединение с базой данных с помощью библиотеки sqlite3.
Создай новую таблицу datamart в базе данных, объединив таблицы pageviews и checker с помощью только одного запроса.
Таблица должна содержать следующие столбцы: uid, labname, first_commit_ts, first_view_ts.
first_commit_ts — это просто новое имя для столбца timestamp из таблицы checker; он показывает первый коммит конкретного лабораторного задания конкретного пользователя.
first_view_ts — первое посещение пользователем из таблицы pageviews, метка времени посещения пользователем ленты новостей.
По-прежнему нужно использовать фильтр status = 'ready'.
По-прежнему нужно использовать фильтр numTrials = 1.
Имена лабораторных заданий по-прежнему должны быть из следующего списка: laba04, laba04s, laba05, laba06, laba06s, project1.
Таблица должна содержать только пользователей (uid с user_*), а не администраторов.
first_commit_ts и first_view_ts должны быть распарсены как datetime64[ns].
Используя методы библиотеки Pandas, создай два датафрейма: test и control.
test должен включать пользователей, у которых имеются значения в first_view_ts.
control должен включать пользователей, у которых отсутствуют значения в first_view_ts.
Замени пропущенные значения в control средним значением first_view_ts пользователей из test (оно пригодится нам для анализа в будущем).
Сохрани обе таблицы в базе данных (вы будете использовать их в следующих упражнениях).
Закрой соединение.
Небольшой совет — выполняй все операции поочередно, от простой к более сложной, а не пытаясь сделать всё вместе и сразу. Это поможет в отладке твоих запросов.

Task 4
На предыдущих этапах ты занимался просто подготовкой данных. Ты не получил никакой аналитической информации на основе имеющихся данных. Пришло время приступить к анализу. Помни, что, согласно нашему предположению, пользователи приступили бы к работе над лабораторными заданиями раньше, если бы они просмотрели ленту новостей? Это означает, что ключевой метрикой для нас является период времени (delta) между датой начала работы пользователя над лабораторным заданием (первого коммита) и сроком сдачи лабораторного задания. Мы будем смотреть на то, меняется ли она в зависимости от просмотра страницы.

Что тебе нужно сделать в этом упражнении:

Создай соединение с базой данных с помощью библиотеки sqlite3.
Получи схему таблицы test.
Получи только первые 10 строк таблицы test, чтобы проверить, как она выглядит.
Найди среди всех пользователей минимальное значение этой самой дельты (периода времени от даты первого коммита пользователя до срока сдачи соответствующего лабораторного задания), используя только один запрос.
Для этого сджойни данные своей таблицы с данными таблицы deadlines.
Период времени должен отображаться в часах.
Не учитывай лабораторное задание project1 с более длительным сроком сдачи, поскольку оно будет выделяться на фоне других.
Сохрани значение в датафрейме df_min с соответствующим uid.
Выполни те же самые операции для максимального значения дельты, используя только один запрос. Название итогового датафрейма — df_max.
Выполни те же самые операции для среднего значения дельты, используя только один запрос. На этот раз ваш итоговый датафрейм не должен включать столбец uid; имя датафрейма — df_avg.
Мы хотим проверить предположение о том, что у пользователей, посетивших ленту новостей всего несколько раз, период времени между датой первого коммита и сроком сдачи лабораторного задания меньше. Для этого тебе необходимо рассчитать коэффициент корреляции между количеством просмотров страниц и разницей между датами.
Используя только один запрос, создай таблицу со столбцами: uid, avg_diff, pageviews.
uid — это uid, существующие в таблице test.
avg_diff — среднее значение дельты (периода времени между датой первого коммита и сроком сдачи лабораторного задания) для каждого пользователя.
pageviews — количество посещений ленты новостей одним пользователем.
Не учитывай лабораторное задание project1.
Сохрани результаты в датафрейме views_diff.
Используй метод corr() библиотеки Pandas для вычисления коэффициента корреляции между количеством просмотров и значением дельты.
Закрой соединение.
Task 5
Итак... давай, наконец, выясним, повлияло ли посещение ленты новостей на поведение учащихся. Приступили ли они в итоге к работе над лабораторным заданием раньше? Помни, что у нас есть две подготовленные таблицы в базе данных: test и control. Мы выполним нечто, похожее на A/B-тестирование. Чтобы обнаружить эффект, нам нужно вычислить значение дельты (период времени между датой первого коммита и сроком сдачи лабораторного задания) до того момента, когда учащиеся впервые посетили страницу с лентой новостей, и после этого. Мы должны сделать то же самое и для контрольной группы.

Другими словами, каждый пользователь из тестовой таблицы имеет свою собственную временную метку для первого посещения новостной ленты. Мы хотим вычислить среднее значение дельты (разницу между датой первого коммита и сроком сдачи) до этой временной метки и после нее. Мы сделаем то же самое для пользователей в контрольной группе. Ты можешь сказать: «Но они вообще не посещали ленту новостей». Это так, и ранее мы решили использовать среднюю временную метку первого просмотра пользователями тестовой группы для пользователей контрольной группы.

Если значение дельты перед первым посещением ленты новостей значительно отличается от этого показателя после первого посещения в тестовой группе, и мы не видим аналогичного эффекта в контрольной группе, значит, создание страницы с новостной лентой было отличной идеей. Мы можем распространить эту практику на всю группу.

Подробное описание:

Создай соединение с базой данных с помощью библиотеки sqlite3.
Используя только один запрос для каждой из групп, создай два датафрейма: test_results и control_results со столбцами time и avg_diff и только двумя строками.
times должно иметь значения before и after.
avg_diff содержит среднее значение дельты для всех пользователей за период времени до первого посещения ленты новостей каждым из них и после этого.
Учитываются только те пользователи, для которых имеются наблюдения и before, и after.
Мы по-прежнему не используем лабораторное задание 'project1'.
Закрой соединение.
Дайте ответ: оказалось ли предположение верным и влияет ли наличие страницы с новостной лентой на поведение учащихся?
